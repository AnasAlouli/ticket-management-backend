const express = require("express")
const cors = require("cors")
const multer = require("multer")
const XLSX = require("xlsx")
const fs = require("fs")
const path = require("path")

const app = express()
const PORT = 5000

// Middleware
app.use(cors())
app.use(express.json())

// Configuration des dossiers
const EXCEL_DIR = path.join(__dirname, "excel")
const UPLOADS_DIR = path.join(__dirname, "uploads")
const TEMP_DIR = path.join(__dirname, "temp")

// Cr√©er les dossiers s'ils n'existent pas
;[EXCEL_DIR, UPLOADS_DIR, TEMP_DIR].forEach((dir) => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true })
  }
})

// Configuration multer pour l'upload
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, UPLOADS_DIR)
  },
  filename: (req, file, cb) => {
    const timestamp = Date.now()
    const originalName = file.originalname.replace(/[^a-zA-Z0-9.-]/g, "_")
    cb(null, `upload_${timestamp}_${originalName}`)
  },
})

const upload = multer({
  storage: storage,
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB max
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = [
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      "application/vnd.ms-excel",
    ]
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true)
    } else {
      cb(new Error("Type de fichier non support√©"), false)
    }
  },
})

// Variables globales pour le stockage temporaire
let currentTicketsData = []
let lastLoadedFile = null
let dataCache = {
  data: [],
  lastModified: null,
  source: null,
}

// Fonction pour lire un fichier Excel
function readExcelFile(filePath) {
  try {
    console.log(`üìñ Lecture du fichier: ${filePath}`)

    if (!fs.existsSync(filePath)) {
      console.log(`‚ùå Fichier non trouv√©: ${filePath}`)
      return []
    }

    const workbook = XLSX.readFile(filePath)
    const sheetName = workbook.SheetNames[0]
    const worksheet = workbook.Sheets[sheetName]
    const data = XLSX.utils.sheet_to_json(worksheet)

    console.log(`‚úÖ ${data.length} lignes lues depuis ${path.basename(filePath)}`)
    return data
  } catch (error) {
    console.error(`‚ùå Erreur lecture Excel:`, error.message)
    return []
  }
}

// Fonction pour sauvegarder dans Excel
function saveToExcel(data, filename = "tickets.xlsx") {
  try {
    const filePath = path.join(EXCEL_DIR, filename)
    const worksheet = XLSX.utils.json_to_sheet(data)
    const workbook = XLSX.utils.book_new()
    XLSX.utils.book_append_sheet(workbook, worksheet, "Tickets")
    XLSX.writeFile(workbook, filePath)

    console.log(`üíæ Donn√©es sauvegard√©es dans ${filename}`)
    return true
  } catch (error) {
    console.error("‚ùå Erreur sauvegarde Excel:", error.message)
    return false
  }
}

// Fonction pour charger les donn√©es depuis le fichier principal
function loadMainData() {
  const mainFile = path.join(EXCEL_DIR, "tickets.xlsx")

  if (fs.existsSync(mainFile)) {
    const stats = fs.statSync(mainFile)

    // V√©rifier si le cache est encore valide
    if (
      dataCache.lastModified &&
      dataCache.lastModified.getTime() === stats.mtime.getTime() &&
      dataCache.source === "main"
    ) {
      console.log("üìã Utilisation du cache (fichier principal)")
      return dataCache.data
    }

    const data = readExcelFile(mainFile)

    // Mettre √† jour le cache
    dataCache = {
      data: data,
      lastModified: stats.mtime,
      source: "main",
    }

    currentTicketsData = data
    lastLoadedFile = mainFile
    return data
  }

  console.log("‚ö†Ô∏è Aucun fichier principal trouv√©")
  return []
}

// Fonction pour charger les donn√©es temporaires
function loadTempData() {
  if (currentTicketsData.length > 0 && dataCache.source === "temp") {
    console.log("üìã Utilisation des donn√©es temporaires en m√©moire")
    return currentTicketsData
  }

  // Fallback vers le fichier principal
  return loadMainData()
}

// Routes API

// GET /api/tickets - R√©cup√©rer tous les tickets
app.get("/api/tickets", (req, res) => {
  try {
    const tickets = loadTempData()

    res.json(tickets)
    console.log(`üìä ${tickets.length} tickets envoy√©s au frontend`)
  } catch (error) {
    console.error("‚ùå Erreur GET /api/tickets:", error.message)
    res.status(500).json({
      message: "Erreur lors du chargement des tickets",
      error: error.message,
    })
  }
})

// POST /api/tickets - Cr√©er un nouveau ticket
app.post("/api/tickets", (req, res) => {
  try {
    const newTicket = req.body

    // Validation des champs requis
    const requiredFields = ["Incident Number", "Caller name", "Country (Caller)"]
    const missingFields = requiredFields.filter((field) => !newTicket[field])

    if (missingFields.length > 0) {
      return res.status(400).json({
        message: `Champs requis manquants: ${missingFields.join(", ")}`,
      })
    }

    // Charger les donn√©es actuelles
    const tickets = loadTempData()

    // V√©rifier si le ticket existe d√©j√†
    const exists = tickets.some((t) => t["Incident Number"] === newTicket["Incident Number"])
    if (exists) {
      return res.status(400).json({
        message: "Un ticket avec ce num√©ro existe d√©j√†",
      })
    }

    // Ajouter le nouveau ticket
    tickets.push(newTicket)

    // Mettre √† jour les donn√©es temporaires
    currentTicketsData = tickets
    dataCache = {
      data: tickets,
      lastModified: new Date(),
      source: "temp",
    }

    // Sauvegarder dans le fichier principal
    const saved = saveToExcel(tickets)

    if (!saved) {
      return res.status(500).json({
        message: "Erreur lors de la sauvegarde",
      })
    }

    console.log(`‚úÖ Nouveau ticket cr√©√©: ${newTicket["Incident Number"]}`)
    res.json({
      message: "Ticket cr√©√© avec succ√®s",
      ticket: newTicket,
    })
  } catch (error) {
    console.error("‚ùå Erreur POST /api/tickets:", error.message)
    res.status(500).json({
      message: "Erreur lors de la cr√©ation du ticket",
      error: error.message,
    })
  }
})

// PUT /api/tickets/:id - Mettre √† jour un ticket
app.put("/api/tickets/:id", (req, res) => {
  try {
    const id = req.params.id
    const updatedData = req.body

    const tickets = loadTempData()
    const index = tickets.findIndex((t) => t["Incident Number"] === id)

    if (index === -1) {
      return res.status(404).json({
        message: "Ticket non trouv√©",
      })
    }

    // Mettre √† jour le ticket
    tickets[index] = { ...tickets[index], ...updatedData }

    // Mettre √† jour les donn√©es temporaires
    currentTicketsData = tickets
    dataCache = {
      data: tickets,
      lastModified: new Date(),
      source: "temp",
    }

    // Sauvegarder dans le fichier principal
    const saved = saveToExcel(tickets)

    if (!saved) {
      return res.status(500).json({
        message: "Erreur lors de la sauvegarde",
      })
    }

    console.log(`‚úÖ Ticket mis √† jour: ${id}`)
    res.json({
      message: "Ticket mis √† jour avec succ√®s",
    })
  } catch (error) {
    console.error("‚ùå Erreur PUT /api/tickets:", error.message)
    res.status(500).json({
      message: "Erreur lors de la mise √† jour",
      error: error.message,
    })
  }
})

// DELETE /api/tickets/:id - Supprimer un ticket
app.delete("/api/tickets/:id", (req, res) => {
  try {
    const id = req.params.id

    const tickets = loadTempData()
    const filteredTickets = tickets.filter((t) => t["Incident Number"] !== id)

    if (tickets.length === filteredTickets.length) {
      return res.status(404).json({
        message: "Ticket non trouv√©",
      })
    }

    // Mettre √† jour les donn√©es temporaires
    currentTicketsData = filteredTickets
    dataCache = {
      data: filteredTickets,
      lastModified: new Date(),
      source: "temp",
    }

    // Sauvegarder dans le fichier principal
    const saved = saveToExcel(filteredTickets)

    if (!saved) {
      return res.status(500).json({
        message: "Erreur lors de la sauvegarde",
      })
    }

    console.log(`üóëÔ∏è Ticket supprim√©: ${id}`)
    res.json({
      message: "Ticket supprim√© avec succ√®s",
    })
  } catch (error) {
    console.error("‚ùå Erreur DELETE /api/tickets:", error.message)
    res.status(500).json({
      message: "Erreur lors de la suppression",
      error: error.message,
    })
  }
})

// POST /api/upload - Upload fichier Excel
app.post("/api/upload", upload.single("excelFile"), (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        message: "Aucun fichier fourni",
      })
    }

    const uploadedFilePath = req.file.path
    console.log(`üì§ Fichier upload√©: ${req.file.filename}`)

    // Lire le fichier Excel upload√©
    const data = readExcelFile(uploadedFilePath)

    if (data.length === 0) {
      // Supprimer le fichier upload√©
      fs.unlinkSync(uploadedFilePath)
      return res.status(400).json({
        message: "Le fichier Excel est vide ou illisible",
      })
    }

    // Valider les donn√©es
    let validRows = 0
    let invalidRows = 0

    data.forEach((row) => {
      const requiredFields = ["Incident Number", "Caller name", "Country (Caller)"]
      const hasAllFields = requiredFields.every((field) => row[field])

      if (hasAllFields) {
        validRows++
      } else {
        invalidRows++
      }
    })

    // Stocker temporairement les donn√©es en m√©moire
    currentTicketsData = data
    dataCache = {
      data: data,
      lastModified: new Date(),
      source: "temp",
    }

    // Cr√©er une copie dans le dossier temp avec timestamp
    const timestamp = Date.now()
    const tempFileName = `temp_${timestamp}_${req.file.originalname}`
    const tempFilePath = path.join(TEMP_DIR, tempFileName)

    // Copier le fichier vers temp
    fs.copyFileSync(uploadedFilePath, tempFilePath)

    // Sauvegarder aussi dans le fichier principal
    const mainFilePath = path.join(EXCEL_DIR, "tickets.xlsx")
    const worksheet = XLSX.utils.json_to_sheet(data)
    const workbook = XLSX.utils.book_new()
    XLSX.utils.book_append_sheet(workbook, worksheet, "Tickets")
    XLSX.writeFile(workbook, mainFilePath)

    // Supprimer le fichier d'upload original
    fs.unlinkSync(uploadedFilePath)

    console.log(`‚úÖ Fichier trait√© et stock√© temporairement`)
    console.log(`üìä ${validRows} lignes valides, ${invalidRows} lignes invalides`)
    console.log(`üíæ Copie temporaire: ${tempFileName}`)

    res.json({
      message: "Fichier upload√© et trait√© avec succ√®s",
      fileName: req.file.originalname,
      totalRows: data.length,
      validRows,
      invalidRows,
      filePath: tempFileName,
      tempStorage: true,
    })
  } catch (error) {
    console.error("‚ùå Erreur upload:", error.message)

    // Nettoyer le fichier en cas d'erreur
    if (req.file && fs.existsSync(req.file.path)) {
      fs.unlinkSync(req.file.path)
    }

    res.status(500).json({
      message: "Erreur lors de l'upload du fichier",
      error: error.message,
    })
  }
})

// POST /api/reload - Recharger les donn√©es depuis le fichier principal
app.post("/api/reload", (req, res) => {
  try {
    console.log("üîÑ Rechargement des donn√©es...")

    // Vider le cache
    dataCache = {
      data: [],
      lastModified: null,
      source: null,
    }

    // Recharger depuis le fichier principal
    const data = loadMainData()

    res.json({
      message: "Donn√©es recharg√©es avec succ√®s",
      totalRows: data.length,
      source: "main",
    })
  } catch (error) {
    console.error("‚ùå Erreur reload:", error.message)
    res.status(500).json({
      message: "Erreur lors du rechargement",
      error: error.message,
    })
  }
})

// GET /api/status - Statut du serveur et des donn√©es
app.get("/api/status", (req, res) => {
  try {
    const mainFile = path.join(EXCEL_DIR, "tickets.xlsx")
    const mainFileExists = fs.existsSync(mainFile)

    let mainFileStats = null
    if (mainFileExists) {
      const stats = fs.statSync(mainFile)
      mainFileStats = {
        size: stats.size,
        modified: stats.mtime,
        rows: 0,
      }

      try {
        const data = readExcelFile(mainFile)
        mainFileStats.rows = data.length
      } catch (e) {
        // Ignore errors for status
      }
    }

    res.json({
      server: "running",
      port: PORT,
      tempDataRows: currentTicketsData.length,
      cacheSource: dataCache.source,
      cacheLastModified: dataCache.lastModified,
      mainFile: {
        exists: mainFileExists,
        path: mainFileExists ? mainFile : null,
        stats: mainFileStats,
      },
      directories: {
        excel: EXCEL_DIR,
        uploads: UPLOADS_DIR,
        temp: TEMP_DIR,
      },
    })
  } catch (error) {
    res.status(500).json({
      message: "Erreur lors de la r√©cup√©ration du statut",
      error: error.message,
    })
  }
})

// Initialisation au d√©marrage
console.log("üöÄ Initialisation du serveur...")
console.log(`üìÅ Dossier Excel: ${EXCEL_DIR}`)
console.log(`üìÅ Dossier Uploads: ${UPLOADS_DIR}`)
console.log(`üìÅ Dossier Temp: ${TEMP_DIR}`)

// Charger les donn√©es initiales
const initialData = loadMainData()
console.log(`üìä ${initialData.length} tickets charg√©s au d√©marrage`)

// D√©marrage du serveur
app.listen(PORT, () => {
  console.log(`‚úÖ Serveur Express d√©marr√© sur le port ${PORT}`)
  console.log(`üåê API disponible sur http://localhost:${PORT}/api`)
  console.log(`üìã Statut: http://localhost:${PORT}/api/status`)
})

// Gestion propre de l'arr√™t
process.on("SIGINT", () => {
  console.log("\nüõë Arr√™t du serveur...")

  // Sauvegarder les donn√©es temporaires si n√©cessaire
  if (currentTicketsData.length > 0 && dataCache.source === "temp") {
    console.log("üíæ Sauvegarde des donn√©es temporaires...")
    saveToExcel(currentTicketsData)
  }

  console.log("‚úÖ Serveur arr√™t√© proprement")
  process.exit(0)
})
